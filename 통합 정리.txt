노드 서버 설정
npm init


시스템 이벤트 

process 객체는 노드에서 항상 사용할 수 있는 객체 입니다.
on()과 emit() 메소드는 객체를 생성하거나 모듈을 가져오지 않아도 바로사용할 수 있습니다.
on() 메소드를 호출하면서 이벤트 이름을 exit로 지정하면 내부적으로 프로세스가 끝날 때를 알 수 있습니다.



익스프레스 모듈
미들웨어와 라우터를 사용하여 편리하게 웹서버를 구성할 수 있습니다.
메소드 
use() : 미들웨어 함수를 사용합니다
get() : get으로 사용자 정보를 전달 받습니다.
set() : 서버설정을 위한 속성을 설정합니다.
redirect():웹페이지의 경로를 강제로 이동시킵니다.
send() : 클라이언트에 응답 데이터를 보냅니다.
        전달할 수있는 데이터는 html, buffer, json, json배열.. 등입니다.
header() : 헤더를 확인합니다.


package설치하기
npm i express


포스트맨 다운로드
https://www.postman.com/downloads/

REST란?
"Representational State Transfer"의 약자
자원을 이름으로 구분하여 해당 자원의 상태를 주고 받는것을 의미합니다.
CRUD연산 => 데이터베이스

CREATE : 생성(POST)
READ : 조회(GET)
UPDATE : 수정(PUT)
DELETE : 삭제(DELETE)

Router 미들웨어
사용자의 다양한 요청이 들어왔을때 use() 메소드로 설정한 미들웨어가 항상 호출되는 불편한점이 있습니다.
이를 해결하고자 사용하는 미들웨어가 Router 미들웨어입니다.

Router 객체 만들기
const 라우터 객체 = express.Router();

http://localhost:3000/member/login
라우터객체.router(요청패스).get(실행할 함수);
라우터객체.router(요청패스).post(실행할 함수);

익스프레스에 Router 객체 적용
app.use('/', 라우터객체);


EJS(Embedded JavaScript) 모듈
EJS 모듈은 템플릿 엔진 모듈입니다.
템플릿 엔진 모듈은 특정한 형식인 파일로 부터 HTML 페이지를 생성하는 모듈입니다.

설지 npm i ejs

EJS 파일 형식의 특수 코드 
<% ~~~ code ~~~ %> : 자바스크립트 코드를 입력하는 영역입니다.
<%= 변수 또는 값 %> : 데이터를 출력
<%- 변수 또는 객체 %> : ejs 파일 전체를 전달

EJS epdlxjfmf wjsekf
render() : 메소드의 매개 변수에 전달하고자 하는 데이터를 입력하여 전달합니다.
ejs.render(data);

PUG(구 jade)
https://jade-lang.com 외국에서 쓰는 방식


JSON(JavaScript Object Notation)
데이터를 교환하고 저장하기 위해 만들어진  텍스트 기반의 데이터 교환 표준입니다


cookie-parser 모듈 (npm i cookie-parser)
요청된 쿠키를 사용할 수 있도록 도와주는 모듈입니다. express(req,res) 객체에 cookie를 사용할 수 있도록 기능을 부여합니다.

cookieParser():일반쿠키를 사용하는 경우
cookieParser('암호화하기 위한 문자') : 암호화된 쿠키를 사용하는 경우

res.cookie('키','값',{
    쿠키 생성 옵션
})

쿠키 생성 옵션
maxAge: 만료시간을 밀리초 단위로 설정합니다.
(
    //  maxAge: 1000 * 60 * 60 * 24 * 30
    //          밀리초 초   분   시   일
)
expires : 만료 시간을 GMT 시간으로 설정합니다.
path : cookie의 경로를 설정합니다. 기본설정은 '/' 입니다.

쿠키 조회하기
req.cookies.cookie키 :일반 쿠키
req.signedCookies.cookie키 :암호화된 쿠키

쿠키 삭제하기
res.clearCookie('키',(path:'경로'));


Nodemon 사용
서버 코드를 변경할때마다 서버를 재시작하도록 하는 모듈

npm i -g nodemon

"scripts": {
    "start": "nodemon 파일명.확장자"
},

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

express-session 모듈
express에서 세션을 관리하기 위해 사용한 미들웨어 모듈입니다.
npm i express-session 설치

cookie는 로컬에다 저장
session은 하드웨어에다 저장

app.use(session({세션모듈의 옵션}));
ex)
app.use(expressSession({
    secret:'!@#$%^&*()',
    resave:false,
    saveUninitialized:true
}));


세션모듈의 옵션
secret : 쿠키를 임의로 변조하는 것을 방지하기 위한 값
        ->이 값을 통하여 세션을 암호화 저장합니다
resave : 세션을 언제나 저장할지 지정하는 값
        ->이 값을 false로 하는것을 권장하고 필요에 따라 true로 설정하기도 합니다.
saveUninitialized: 세션이 저장되기 전에 saveUninitialized 상태로 미리 만들어서 저장 
        초기화 되기전 것을 저장할지 여부를 설정

[세션 초기 설정]
let 세션객체명 = req.session;
    세션객체명.변수명 = 값;

ex)
let sess = req.session;
sess.userid = 'apple';

[세션 변수 사용]
세션객체명.변수명;
console.log(sess.userid);

[세션 삭제]
req.session.destory(()=>{
    세션 삭제시 처리할 문자;
})



https://db-engines.com/en/ranking


[NoSQL]
Not only SQL의 약자입니다
기존의 RDBMS(관계형 데이터베이스)의 한계를 극복하기 위해 만들어진 새로운 형태의 데이터 베이스입니다.
관계형 DB가 아니기에 RDBMS처럼 고정된 스키마 및 JOIN 문이 존재하지 않습니다.

NoSQL을 사용하는 이유
가장 큰 이유는 성능 때문입니다.
관계형 데이터 베이스는 시스템의 신뢰도를 높이는데 필요한 장치를 많이 가지고 있습니다.
SQL문을 읽고 실행하는데 많은 리소스를 사용하며 성능이 떨어지는 경우가 많습니다.
반대로 NoSQL은 성능을 최우선으로 생각하며 실시간으로 처리해야 할 경우나 대용량 트래픽을 감당할 수 있는 메시징 시스템등에 활용됩니다.


https://www.mongodb.com/
https://www.mongodb.com/try/download/community



[MongoDB 문법]
몽고 db 접속
mongo 

데이터베이스 확인
show dbs

데이터베이스 생성 및 선택
use 데이터베이스명
use frontenddb
* 데이터베이스가 없으면 생성, 있으면 선택합니다.
* 데이터베이스의 자료가 없을 경우 show dbs에서 나타나지 않습니다

컬렉션 생성
db.createCollection('컬렉션명')
db.createCollection('testCollection')
결과
{"ok":1}

컬렉션 확인
show collections

컬렉션 삭제
db.컬렉션명.drop();
db.testCollection.drop();
결과
true

document추가
db.컬랙션명.insert(객체);
db.member.insert({'userid':'apple','userpw':'1111'});
db.member.insert({'userid':'banana','userpw':'2222','username':'반하나'});
db.member.insert({"userid":"orange","userpw":"3333","gender":"남자"});
db.member.insert({"userid":"melon","userpw":"4444","gender":"남자", "username":"이메론"});
db.member.insert({"userid":"cherry","userpw":"5555", "username":"채리","gender":"여자","point":2000});
db.member.insert({"userid":"avocado","userpw":"6666", "username":"안카도","gender":"남자","point":1500});
db.member.insert({"userid":"berry","userpw":"7777", "username":"배애리","gender":"여자","point":1800});
db.member.insert({"userid":"coconut","userpw":"8888", "username":"고코넛","gender":"남자","point":1700});



document확인
db.컬렉션명.find();
db.컬렉션명.find().pretty();
db.컬렉션명.find(객체).pretty();
db.member.find();
db.member.find().pretty();
db.member.find('userid':'apple').pretty();


mongodb 저장소
dbs -> collection -> 객체

1.cmd -> 몽고db 접속 : mongo
2.데이터 베이스 확인 : show dbs;
3.해당되는 데이터 베이스 접속 => use는 db 생성, 선택(데이터 베이스 명을 명확하게 입력 )
                              : use 데이터 베이스명
                                use frontenddb
4.컬랙션 생성
                db.createCollection('컬렉션명')
                db.createCollection('testCollection')
                결과
                {"ok":1}

5.컬렉션 확인
                show collections

6.컬렉션 삭제
                db.컬렉션명.drop();
                db.testCollection.drop();
                결과
                true

7.document추가
                db.컬랙션명.insert(객체);
                db.member.insert({'userid':'apple','userpw':'1111'})    \

8.document확인 
                db.컬렉션명.find();
                db.컬렉션명.find().pretty(); [json파일형식으로 깔끔하게 보인다.]
                db.컬렉션명.find({객체}).pretty(); [특정 document를 확인할때]
                db.member.find();
                db.member.find().pretty();
                db.member.find({'userid':'apple'}).pretty();


 document 비교연산 -> 값이 크다 작다의 의미가 아니라 하나의 변수값을 선언하는 것
$eq : 주어진 값과 일치하는 값을 찾습니다.
$gt : 주어진 값보다 큰 값을 찾습니다.
$gte : 주어진 값보다 크거나 같은 값을 찾습니다.
$lt : 주어진 값보다 작은 값을 찾습니다.
$lte : 주어진 값보다 작거나 같은 값을 찾습니다.
$ne : 주어진 값과 일치하지 않는 값을 찾습니다.
$in : 주어진 배열 안에 속하는 값을 찾습니다.
$nin : 주어진 배열 안에 속하지 않는 값을 찾습니다.


document 논리연산
$or : 주어진 조건 중 하나라도 true일 때 true인 결과를 찾습니다.
$and : 주어진 모든 조건이 true일 때 true인 결과를 찾습니다.
$not : 주어진 조건이 false일 때 true, true일 때 false인 결과를 찾습니다.

문제.
아이디가 "melon"이고 이름이 "이메론"인 멤버를 검색합니다.
db.member.find({$and:[{'userid':'melon'},{'username':'이메론'}]}).pretty();

->조건이 2가지 이상이면 배열되므로 $and:[]로 표시
->객체는 무조건{}


document 정렬
db.컬랙션명.find().sort({객체:-1})
db.member.find().sort({"_id"}).pretty();

객체
{key:value} -> key는 데이터의 field이름, value의 값은 1(오름차순) 또는  -1(내림차순)
여러 key를 입력할수 있고, 먼저 입력한 key가 우선권을 갖음.

document의 개수 제한
limit():출력할 데이터 개수를 제한 할때 사용
db.컬랙션명.find().limit(출력할개수)
db.member.find().limit(3).pretty();

document 데이터 생략 후 출력
skip():출력할 데이터의 시작 부분을 설정할 경우 사용
db.컬랙션명.find().skip(생략할개수)
db.member.find().skip(3).pretty();





파일 업로드     
multer 모듈
파일 업로드를 위한 익스프레시에 적용하는 미드웨어 입니다.

server-static 모듈
특정 폴더를 요청에 의해서 직접파일 접근할 수 있도록 기능을 제공하는 익스프레스 미들웨어.


morgan 모듈
로그를 관리하기 위한 별도의 라이브러리 모듈


multer()
생성자에 diskStorage 설정과 파일크기를 설정합니다.

multer.diskStorage{
    destination:저장될 폴더를 설정합니다
    filename:저장될 파일이름을 설정합니다

}
multer({
    storage:storage,//diskStorage설정객체
    limit:{
        file:5,//파일 전송 갯수
        fileSize : 1024*1024*100//파일 전송 용량 1024 * 1024 *100메가

    }
})

mongodb 속도(스키마가 없음), 보안약함 -> 소규모프로젝트
mongodb 속도가 느림, 보안이 강함, 확장성 -> 대형프로젝트

mongoose 모듈
mongodb -> mongoose(스키마) -> 제약조건

MongoDB의 ODM(object data mapping)
몽고디비를 사용하면 하나의 컬렉션 안에 똑같은 속성을 가진 문서 객체를 반복적으로 넣어둔다면
데이터를 조회할때도 어떤 속성들이 있는지 미리알고 있는 상태에서 조회할수있습니다.
관계형 데이터베이스처럼 테이블이나 엑셀시트와 같이 쉽게 데이터를 다룰 수 있도록 제공합니다
- 스키마 생성

MongoDB의 ODM(object data mapping) => 데이터베이스와 객체지향 프로그래밍 언어 사이 호환되지 않는
데이터를 변환하는 기법

메소드
connect() : mongoose를 사용해 데이터베이스를 연결
        mongose객체.connect(url[옵션,콜백])
        url : mongo://ip:port/db명

model() : 모델을 정의합니다. 
Schema() : 스키마를 정의하는  생성자

스키마
 - 데이터 유효성 검증을 위해 스키마를 사용
 - 데이터 타입 및 규약등 설정
 - 스키마에 사용되는 테마는
    String, Number, Date, Boolean, Array ......

모델
 - 데이터베이스에서 데이터를 읽고 생성하고 수정하는 인테페이스를 정의 함
   Mongose객체, modul(컬랙션 명, 스키마 명)
   컬렉션이름을 지정하지않으면 1번째 매개변수에 붙여 복수형으로 사용






리액트

npm -> yarn 설치 npm i yarn --gobal

프로젝트 생성
    yarn create react-app 프로젝트명